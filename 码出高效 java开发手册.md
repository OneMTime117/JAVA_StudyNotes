# 码出高效 java开发手册

## 1、计算机基础

从编程角度深度探讨计算机组成原理、计算机网络、信息安全等相关内容

### 1.1 走进0与1的世界

​	1、计算机就是有晶体管和电路板组成，无论是图像渲染、网络远程共享，还是大数据计算，归根到底都是对0与1的信号处理；而0与1是通过各种介质中的物理表现形式进行区分的，如三极管的通断、CPU的高低电平、磁盘的电荷左右方向

​	2、由多个0和1的组合排列，就组成了一个二进制数，它们能够表示对应的十进制数；以一个八位二进制为例，它可以有2的8次方种排序，即能表示256种信号（十进制），由于在现实生活中，常常存在负数，因此将最高位作为正负数的判断（0位正，1位负），这样一个八位二进制数就可以表示-128~127的整数范围（00000000代表0；10000000代表-128）

​	3、由于二进制有负数的表现形式，因此可以将减法运算转换为对负数的加法运算，从而降低CPU内部的设计复杂度，使计算更加高效

​	4、二进制数有三种表示方式：原码、反码和补码，用于优化二进制的负数加法运算

原码：正常的二进制表示方式

反码：当使用负数二进制做加法运算时，发现无法得出正确结果；因此就引入的反码，**对于负数即在原码基础上，符号为不变，其他位取反；而正数的反码就是原码本身**；将两个加数同时反码，然后进行加法运算，之后在对结果进行取反，此时二进制就能表示正确结果

补码：当使用反码来进行-1与+1相加时，会发生结果为-0的情况（11111111的反码是10000000），不符合现实中只有0的存在；因此就引入了补码，**对于负数即在原码基础上，符号为不变，其他位取反，然后低位补1；而正数的反码就是原码本身**；将两个加数同时转化为补码，然后进行加法运算，之后在对结果进行取反低位补1，此时二进制就能表示正确结果

**因此最终进行带有负数的加法运算时，使用补码方式来优化运算**；即两个二进制数相加的正确结果，为它们补码相加结果的取反低位补1（若结果为10000000，则不需要转换，直接表示为-128）

为了消除-0，规定10000000代表十进制-128的补码（直接使用10000000参与加法运算，之后再结果取反低位补1）；**并且-128没有原码和反码的表示**

​	5、二进制的位移运算，通过对二进制数的位移，可以使计算机更加高效的进行高低位截取、哈希计算、乘除法运算；同样的二进制位移运算也是使用补码进行操作

​	**二进制带符号位移运算（>>、<<），除负数往右移动最高位补1外，其他情况均补0**

​	**二进制无符号右移动（>>>,不存在无符号左移，因为左移不需要考虑是否有符号），直接高位补0；并且负数无符号移动时，最小值为1，以32位为例，当>>32位时的结果为它本身，>>33位的结果和>>1的结果一致，即每移动32位为一次循环，然后就从原有二进制移动，并且对于负数，当>>31位时，最右边为1，左边均为0，达到最小值1**

​	二进制还有其它位运算，取反 ~、位与 &、位或 |；位与&和逻辑与&&都可以使用在条件表达式中，但其表现不同，逻辑与&&具有短路功能，当前者条件成立后，就不会继续进行后者的处理和判断；并且&&只能使用在布尔类型中，而&既可以进行布尔类型的逻辑运算，又可以进行位与的位运算

### 1.2、定点数与浮点数

​		计算机定义了两种小数，分别为定点数和浮点数。定义数为小数点位置固定，从而确定一段数字的整数和小数部分；浮点数采用的科学计数法来近似表示，由符号位、有效数字、指数三部分组成；

​		定点数由于是在一串数字中确定小数点的位置，因此可以表现的数字范围太小，并且运算时容易产生溢出；但是在表现上更加直观准确，在有效范围内是绝对精度。java中可以通过BigDecimal对象来使用该小数表现方式

#### 1.2.1、浮点数的表示

​		在数学中，采用十进制科学计数法来近似表示一个极大或极小且位数多的数。通过a* 10^n ,其中a的绝对值在1到10之间，并且可以简写为 aen；如-4.86e11 等价于 -4.86 * 10……11，表示的真实值为-486000000000。其中- 为符号，4.86为有效数字，11为指数

​		浮点数则采用二进制数来表示科学计数法中的符号、指数和有效数字。由于使用了科学计数法，因此不能够保证表示的是绝对精度，但是表示的数字范围非常大；在业界IEEE754规范中，规定了四种浮点数类型：单精度、双精度、延伸单精度和延伸双精度；java采两用前种使用，它们取值范围为：

| 精度   | 字节数 | 正数取值范围            | 负数取值范围             |
| ------ | ------ | ----------------------- | ------------------------ |
| 单精度 | 4      | 1.4e-45  至  3.4e+38    | -3.4e+38  至 -1.4e-45    |
| 双精度 | 8      | 4.9e-324  至 1.798e+308 | -1.798e+308 至 -4.9e-424 |

由于浮点数不能表示0，因此取值范围分为两个区间：正数区间和负数区间；双精度浮点数只是因为位数翻倍，因此表示范围大，原理和单精度浮点一致，因此以单精度浮点为例：

一共占4个字节，32位，分别含有符号位（分配了1位表示浮点数符号，0为正，1为负）、阶码位（分配了8位来存储指数对应的移码）和尾数位（分配了23位来存储有效数字的原码）

指数的移码：指一个真值正向平移的一个偏移量得到的值的原码，IEEE754规定，阶码（指数的移码）= 指数 + 2的7次方 -1（127）；节码为无符号的8位二进制，并规定位数全0为0，位数全1为无穷的，因此范围位[1,254]，因此指数的范围为[-126,127]

尾数位的取值：由于科学计数法规定有效数字在1到10之间，因此默认尾数位取值形式为1.x，取值范围为[1,2]；是通过1.后面23位0或1组成的小数二进制得到；然后在将该小数二进制转化为十进制的有效数字

**小数二进制转化十进制的规则：**和普通二进制数一样，如11.11  1* 2^1+1 * 2^0+1 * 2^-1+1 * 2^-2= 3.75

综上所述，单精度最大正数为：符号位为1、阶码位为 11111111  即整个有关指数的结果集为2^127=1.7* 10^38、尾数位23个1 近似为2，最大正数为 2* 1.7*10^38=3.4e+38

浮点数的规格表示：

| 数值  | 浮点数二进制表示                                             | 说明                                                         |
| ----- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| -16   | <font color=red>1</font><font color=green>100-0001-1</font>000-0000-0000-0000-0000-0000 | 1*2^(131-127)                                                |
| 16.35 | <font color=red>0</font><font color=green>100-0001-1</font>000-0010-1100-1100-1100-1101 | 1.00000101100110011001101 小数二进制对应十进制为1.0218750238...*2^(131-127)=16.35000032 ,因此计算机实际存储值可能和真值不一样 |
| 0.35  | <font color=red>0</font><font color=green>011-1110-1</font>011-0011-0011-0011-0011-0011 | 1.399999*2^(125-127)=0.3499999                               |

1.2.2、浮点数的加减运算

​		在数学中进行小数加减运算时，需要先将小数点对齐，然后再进行同位数加减。因此在对采用科学计数法表示的数进行加减时，需要保证其指数一样，从而使两个的2的幂结果保持一致，这样就能保证有效数字进行加减后小数点能保持对齐

​		浮点数的加减运算过程如下：

1、零值检查：浮点数规定当阶码位和尾数位全为0时，该值为0，因此两数运算结果直接省略，为另一个数本身（这样减少不必要的操作，提高浮点运算性能）

2、对阶操作：比较两个浮点数的阶码是否相同，当尾码向右移动一位时，相当于有效数字除以2，则指数就需要加1，即阶码加1；由于尾码向右移的误差要比向左移的误差小很多（右移是失去了最小位的精度，左移是失去最大位精度），因此IEE754规定对阶操作只能向右移动，因此选择阶码小的浮点数进行操作

​		由于尾数位默认隐藏了一个最高位1，在向右移动时，最高位还是默认为1

​		由此可以阶码主要是为了进行对阶操作，因此采用移码来简化比较过程

3、尾数求和：当对阶完成时，就可以直接对尾数进行加法（负数需要先转化为补码）；需要将符号位和尾数位隐藏的最高位一起进行计算

4、结果规格化：当运算结果满足规格化时（即尾数相加结果在1到2间），则无需处理；当不满足时，需要对尾数进行移动左移动，保证尾数位隐藏的最高位为1，同时阶码也需要减去移动位数

5、结果舍入：在进行对阶和规格化种，尾数在左移或右移时，都会丢失低位数字，导致结果精度损失；因此计算机为了减少这种精度损失，会将这些失去的低位数字保存起来，称为保护位，等规格化后再根据保护位进行舍入

以1  和 -0.9两个浮点数相加为例：

1 的浮点二进制为：0011-1111-1000-0000-0000-0000-0000-0000

符号位 0   阶码 127  尾数（包含隐藏的最高位）  1000-0000-0000-0000-0000-0000  尾数补码为本身

0.9的浮点二进制为：1011-1111-0110-0110-0110-0110-0110-0110

符号位 1  阶码 126   尾数（包含隐藏的最高位）  1110-0110-0110-0110-0110-0110  尾数补码（符号位为1，因此尾数补码取反+1） 0001-1001-1001-1001-1001-1001

- 对阶：0.9的尾数左移，阶码+1；此时尾数为（最高位默认为1） 1111-0011-0011-0011-0011-0011 尾数补码  1000-1100-1100-1100-1100-1101

- 尾数求和：

  1的符号位+尾数       0 1000-0000-0000-0000-0000-0000

  0.9的符号位+尾数    1 1000-1100-1100-1100-1100-1101

  结果：                       0 0000-1100-1100-1100-1100-1101（结果符号位为0，因此不需要取反+1）

- 规格化：需要保证结果的尾数位最高位为1，因此尾数左移4位，阶码减4；因此左移后阶码等于123（二进制位01111011），尾数为1100-1100-1100-1100-1101-0000，隐藏最高位1，综上所述结果为浮点数二进制为；

  0011-1101-1100-1100-1100-1100-1101-0000 即 1.6000003814..*2^(123-127)=0.100000024

#### 1.2.3 浮点数的使用

​		1、在使用浮点数时，推荐使用双精度，因为单精度的有效位数最多只有7位；而多精度有效位数有15或16位，超出部分会进行四舍五入；也因此双精度和单精度在使用时，会有微小的误差

​		2、在绝对精确的业务场景，一定是使用整型数来表示最小单位的值，如货币使用分来保存；

​		3、在要求精确小数带你后n位的业务场景（n非常大），使用双精度浮点数就无法保证超出有效范围位数后的精度，因此就需要采用数组形式去保存；

​		4、由于浮点数存储时使用科学计数法进行近似，因此当两个浮点数进行运算后，误差将会变大体现出来，导致结果和实现生活不同，所以禁止使用浮点数和其运算结果进行相等判断；

​		5、在使用数据库存储小数时，推荐使用decimal类型，禁止使用float、double（这两种存在精度损失）

#### 1.2.4 十进制小数转化为单精度浮点数二进制过程

​		我们了解了单精度浮点数二进制是由4个字节（32位）组成；符号位、阶码位、尾数位；首先我们可以直接确定符号位，然后将小数转化位二进制，即整数部分除2取余从下到上组合排序、小数部分乘2取整从上到下排序；然后将两组排序进行组合，小数点分隔：

![](C:\Users\OneMTime\Desktop\Typora图片\20180613174704222.png)

然后将小数二进制左规或右规，转化位 1.x的进行，移动位数对应阶码大小，将其转化为对应移码，而移动后的结果就为尾码（最高位1隐藏，后面23位，位数过多截取，位数少则向后补0）

### 1.3、字符集与乱码

​		日常开发中，以UTF-8为主要编码，该字符集转化格式实现了Unicode编码风格（国际码，可以实现全球所有语言字符编码）；可以由1~6个Unicode字符进行编码表示对应语言字符，使用字节较少，有限降低数据存储、传输成本

​		数据流从底层数据库到应用层，到Web服务器，再到客户端显示，都会出现字符乱码问题，因此在排除乱码问题时，是一个很长的链路，需要逐一排除。对于数据库，是存储字符之源，它在不同层次，都能够独立设置字符集，如服务器级别、schema级别、表级别，因此为减少麻烦，应保证数据库所有级别的字符集一致

### 1.4、CPU与内存

​		在实际代码的运行环境中，CPU和内存是非常关键的两个部件。CPU就是一个超大规模的集成电路板（电路工艺达到6纳米级别），它内部就是对0与1的电流信号进行处理，单其处理机制非常精密复杂。CPU是由控制器、运算器和寄存器构成：

1、控制器，包含控制单位、指令译码器、指令寄存器；指令寄存器用于存储CPU中的指令集（X86、SSE、MMX，指令集是CPU控制计算机操作的一套指令集合，程序就是一系列一定顺序排序的指令）；指令译码器，就是帮助控制单元完成指令读取、分析、并交给运算器执行操作；控制单位，完成对指令的控制（指令读取、分析、并交给运算器执行操作）；整个控制器就相当于一个编程语言的编译器，将0与1的源码流，通过译码器和控制单元完成对指令的控制，并将结果存回寄存器或内存

2、运算器，核心就是算术逻辑运算单元（ALU），能通过指令执行算术运算和逻辑运算，可以从寄存器中提取或存储数据。运算器是受控制器控制的执行部件，完成所有的运算工作

3、寄存器，是CPU运算时的高速缓存，其结构和大小对CPU的性能有很大影响，（CPU的计算速度远大于数据的读写速度，因此缓存的提高会大大增加CPU的整体性能），目前CPU一般分为3级缓存（L1,L2,L3），读写速度由强到弱，容量由小到大（更快的速度，决定了需要的容量越小）

​		内存是计算机其他设备与CPU沟通的桥梁，它的结构比较简单，核心是存储单元，然后通过地址译码器和读写控制器完成对存储单元数据的读写；它的大小和频率，决定了计算机调用资源的速度和缓存资源的大小（因为计算机中的所有程序都是在内存中运行）

### 1.5、网络协议

​		在计算机诞生后，从单机模式发展到多计算机连接，然后到现在的互联网模式，实现信息共享、多机协助的计算网络；而计算机网路第一个需要解决的问题就是如何无障碍发送和接送数据：发送和接收数据的过程需要相应协议支撑，按合理的方式对数据进行打包和解包，使不同厂商设备在不同操作系统上实现网络互通。

​	TCP/IP（Transmission Control Protocol / Internet Protocol）传输控制协议/因特网互联协议。它是目前流行的网络传输协议框架。严格意义上说，它是一个协议族，包含HTTP、HTTPS、FTP、SMTP、UDP、ARP、PPP、IEEE 802.X等，但TCP、IP是其中最核心的协议；由于TCP/IP是在不断解决实际问题中成长壮大起来的，经过了市场的检验，因此目前基本无法被取代（即使有设计不合理，但已经被人们所习惯）

####  	1.5.1、TCP/IP协议分层框架

​		TCP/IP协议分层框架：被分为四层，从低到高为，链路层（IEEE 802.X/PPP）、网络层（IP/ARP）、传输层（TCP/UDP）、应用层（HTTP/FTP/SMTP）

- 链路层：以字节为单位通过0和1定义数据帧，其中包括：写入源和目标机器的物理地址、传输的数据、校验位

  计算机物理地址也叫做MAC地址，长6个字节共48位，使用十六进制数表示。前24位有管理机构统一分配，后24位由厂商分配，因此每一张网卡，都对应自己唯一的MAC地址，也是计算机在网络中的唯一标识

- 网络层：根据IP定义网络地址，区分网段。在进行数据包传输时，需要知道到目标机器的MCA地址，因此首先判断原机器（A）IP是否和目的机器（B）IP在同一个网段，在同一网段内就使用ARP（地址解析协议）进行MAC寻址，然后直接向B发送数据包；当不在一个网段时，则先将数据包发送给A的网关，并将数据包中的写入源MAC地址由A的MAC地址替换位该网关的MAC地址，发送给下一级设备，循环直到找到Bip的网关，然后使用ARP进行MAC寻址，最后将数据包中的目的MAC地址替换，从而包数据包发送给B

  **因此网络数据传输的关键是MAC地址，而IP是为了找到目标机器所在的网段，并在该网段下目标机器所对应的MAC地址**

  IP分为网络地址和主机地址，而子网掩码就是用于区分网络地址和主机地址；网络地址在同一网段是固定的，主机位随机，而该网段的默认广播地址：主机位全为1；网段的默认网络地址：主机位全为0

  默认子网掩码有三类：255.0.0.0、255.255.0.0、255.255.255.0；它们对应网段最多可容纳的IP个数为：1677万、6万、254（对于第三类默认网段，IP地址最后一位不能为0，因为是该网段的网络地址，不能为255，因为是该网段的广播地址）；当然由于者三类之间可容纳的IP数范围相差非常大，因此对于如需要500个IP的网段，无法满足，因此子网掩码可以是非默认的，只要保证二进制数中前面全为1后面全为0，即为1的对于IP的网络地址，为0的对应IP的主机地。所有子网掩码除了0/255，还可以为254、252、248、240、224、192、128

  除了定义子网掩码的形式确定网段外，还可以通过  ip后面+ /24，这代表了IP前24位为网络地址

- 传输层：数据包通过网络层发送到目标计算机后，应用程序则通过传输层定义逻辑端口，实现网络两边端口与端口间的通信，从而定义数据传输和端口连接方式的规范。最典型的传输层协议就是UDP和TCP
- 应用层：传输层的数据到达应用程序后，通过应用层来以某种统一规定协议格式取解读数据，常见应用层协议有HTTP和SMTP等

综上所述，在程序进行网络信息通信时，应用层打包数据，传输层建立数据传输端口和传输方式，网络层通过IP进行MAC寻址，并完成数据传输，链路层在数据中添加传输双方的MAC地址，并将数据拆分成数据帧，完成具体的数据传输。

另外存在著名的 OSI（开方式系统互联通信参考模型）的七层传输协议，包括物理层、链路层、网络层、传输层、会话层、表示层、应用层，但已经被淘汰

#### 1.5.2、IP协议

​		IP协议首先规定了IP地址格式，给每一个互联网中的计算机设置了一个唯一的详细地址。本身计算机中，每一张网卡都有自己唯一的MAC地址，但是只是通过广播的形式，在互联网千万台计算机中找到目标MAC地址是非常费时间的。因此通过IP地址，我们可以对全世界的网络进行分层管理，先通过IP找到依次逐级找到最上级路由，然后在逐级向下找到ip所在网段的网关，此时在以广播形式，更快的找到目标机器，发送IP报文

​		IP报文结构：

![](C:\Users\OneMTime\Desktop\Typora图片\1588303608(1).jpg)

IP报头中的生存时间TTL，指数据包在传输过程中，最多可经过的路由总数。每经过一个路由器，TTL值减1，当该字段为0时，数据包将被丢弃不会继续发送到下一级路由，并且反向发送ICMP报文，通知源主机目标IP地址在TTL值内，无法被找到，从而防止源主机无休止的发送报文

​		ICMP（Internet Contorl Message Protocol 互联网控制消息协议），它是检测传输网络是否通畅、目标主机是否可达、路由是否可用等网络运行状态的协议。ICMP不传输用户数据，只是对网络健康状态进行评估。我们常用的ping命令就是基于ICMP检测网络状态的工具

IP报头中的挂载协议标识标识IP报文子数据包协议类型，6代表TCP、17代表UDP

IP报文在互联网传输时，要经历多个物理网络，才能从源主机到达目标主机。由于其间各种物理硬件的性能特性不同，因此它们在传输数据帧的最大长度也有不同限制，该最大长度被称为最大传输单元（MTU Maximum Transmission Unit）。因此实际上IP报文在物理网传输时，需要进行分片处理，该工作通过路由器完成

IP是TCP/IP的基石，几乎其所有其他协议都是建立在IP提供服务的基础之上，其中就包括实际应用用于传输稳定有序数据的TCP

#### 1.5.3、TCP协议

​		传输控制协议（TCP Transmission Control Protocol），是一种面向连接、确保数据在端与端之间可靠传输的协议。面向连接：指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”完成传输；确保数据传输可靠：TCP协议会对发送的每个字节进行编码确认，检验每个数据包的有效性，在出现超时情况时，进行重传，并实现滑动窗口和拥塞控制等机制，避免网络状况恶化而影响数据传输。

​		TCP数据包都封装在IP包中，随着IP包一起传输，TCP报文的结构为：

![](C:\Users\OneMTime\Desktop\Typora图片\1588308425(1).jpg)

TCP报头第一行为源机器和目标机器的端口号，通过两端口号和IP报头中的两IP地址组成一个四元组的唯一标识，也就对应一个TCP连接。

​		TCP是面向连接的，因此分为客户端和服务端。当客户端第一次发送请求建立连接的TCP包时，目标机器端口号为服务端所监听的端口号；国际组织定义了一些默认方便识别的端口号：HTTP服务使用80端口、SHH服务使用22端口、HTTPS服务使用443端口

TCP报头第二行和第三行为序列号（seq），各占4个字节。前者是发送数据包中的数据部分第一个字节的序号，即序列号，后者为确认序列号（ack），当该数据包为响应包时，则会使用确认序列号=请求包序列号+1，用于表示前者发送的数据被确认正确收到，并且也是期望收到对方下一个数据包的序列号

、FIN（Finish 标识后面没有数据需要发送，TCP连接可以关闭）

##### 1.5.3.1、TCP的三次握手，建立连接：

​		TCP的三次握手时通过TCP报头中的SYN（Synchronize Sequence Numbers 同步序列数字，即建立连接时的同步信号）、ACK（Acknowledgement 确认数据信号，表示前者发送的数据被确认正确接收）、序列号和确认序列号四个字段实现的。过程如下：

- A机器发送一个数据包，并将SYN置1，表示希望建立TCP连接，设数据包的序列号为X

- B机器接收到A机器发过来的数据包后，通过SYN为1，得知是请求建立TCP连接，于是发送一个响应包。将SYN和ACK都置1，确认序列号置为X+1，从而表示B接收到了A的建立连接请求。设响应包中的序列号为Y

- A收到B的响应包后需要进行确认，将确认包中的ACK置1，并将序列号置为X+1，确认序列号置为Y+1，表示A能接收到B的确认建立连接的响应

  ![](C:\Users\OneMTime\Desktop\Typora图片\1588327569(1).png)

三次握手的目的：完成两端信息对等和防止超时

- 信息对等：保证双方都能确认四类信息（自己的发报能力、自己的收报能力、对方的发报能力和对方的收报能力），才能建立有效连接。在第一次握手时，B机器可以确定自己的收报能力和对方的发报能力；第二次握手时，A机器可以确定自己的收报能力和发报能力、对方的收报能力和发报能力（此时A掌握四类信息）；第三次握手时，B机器可以确定自己的发报能力和对方的收报能力（此时B掌握四类信息）

- 防止超时：由于TCP连接超时时间小于IP报文的TTL生存时间，因此导致A由于在建立连接请求超时下，多次发送，而B确能全部接收；若不使用三次握手，只使用两次握手；就会导致后一次请求建立连接后，被前一个超时建立连接请求破坏，重新建立TCP连接，因此前一次连接断开，而后一次连接在A确认时，A的状态不处于建立连接待响应状态（SYN_SENT），因此会忽略B的确认包，最后导致TCP连接中断；但如果使用三次握手时，当B机器收到超时的建立连接请求后，A机器在接收响应包时，由于不处于SYN_SENT状态(建立连接待响应状态)，则会忽略B的响应包，从不会建立脏连接

三次握手时，客户端和服务端的三种状态：

客户端：LISTENING（端口监听状态） 、SYN_SENT（同步信号已发送状态）、ESTABLISHED（连接建立状态）

服务端：LISTENING（端口监听状态）  、SYN_RCVD（同步信号已收到状态）、ESTABLISHED（连接建立状态）

TCP协议支持KeepAlive功能，即隔断时间向对方发送数据表示连接处于健康状态，当心跳包发送出现异常时，就会主动关闭连接，并回收与TCP连接相关资源，确保系统资源利用率

##### 1.5.3.2、TCP的四次挥手，端开连接：

TCP在建立来连接后，是全双工通信，双方都能作为数据的发送方和接收方。但TCP连接也需要断开，通过ACK（Acknowledgement 确认数据信号，表示前者发送的数据被确认正确接收）、FIN（Finish 表示后面没有数据需要发送，TCP连接可以关闭）、que（序列号）和ack（确认序列号）字段实现，过程如下：

- A机器想要关闭连接，因此发送一个数据包，FIN置1。进入等待关闭连接请求响应状态（FIN_WAIT_1），设序列号为U
- B机器收到A想要关闭连接的请求，发送一个响应包，ACK置1，确认序列号为U+1。表示确认收到了A想要关闭连接的请求，并且同意可以断开，但是需要等待B自己完成之前的数据处理，并做好关闭连接准备，此时B处于等待关闭状态（COLSE_WAIT）；
- 当A收到响应包后，就进入半关闭状态（FIN_WAIT_2），无法发送新数据。此时B做好关闭连接准备后，发送关闭连接的响应包，FIN置1、ACK置1、确认序列号为U+1。此时B机器进入关闭确认状态（LAST_ACK），无法再发送新数据。设此时序列号为W
- 当A收到第二个响应包时，确定B已进入最后确认状态，即随时可以断开连接。此时发送一个确认包，ACK置1，序列号为U+1，确认序列号为W+1；此时A进入TIME_WAIT状态，经过2MSL（Maximum Segment Lifetime  TCP报文在网络中的最长生存时间，超出则直接丢弃）后，进入CLOSED状态

![](C:\Users\OneMTime\Desktop\Typora图片\1588386154(1).jpg)

如果A机器在FIN_WAIT_1状态下，直接收到B机器发送来带有FIN和ACK标志的响应包时（即B机器处于COLSE_WAIT状态），则无需经过FIN_WAIT_2状态，A机器直接发送最后的确认包，进入TIME_WAIT状态

TIME_WAIT状态的持续时间为2MSL。一般来说，MSL大于TTL,在RFC793中规定MSL为2分钟，因此TIME_WAIT状态需要持续4分钟，之后才能转化为CLOSED状态；4分钟等待时间会导致网络资源的极大浪费，但是这样设计是由原因的：

​	1、确保被动关闭的一方能顺利进入CLOSED状态。因为当由于网络原因，最后的确认包到达B机器时，处于LAST_ACK状态的B机器就会以为A机器没有收到自己发送的FIN+ACK报文，所有就会重发。若此时A机器不进行2MSL的等待，则就不一定能收到B机器重发来的FIN+ACK报文。导致自己”自私“的进入CLOSED状态，而B无法进入。

​	2、防止失效请求。若当A机器直接关闭后，又需要建立了AB机器之间相同端口的TCP连接时，此时就可能出现前一个连接的超时数据在该新连接中进行处理。导致和新连接传输的数据报发生混淆；而有了TIME_WAIT状态的超时时间后，就能有效的将那些超时报文进行丢弃。

由于TIME_WAIT状态下无法真正释放句柄资源，对于高并发服务器，会极大的影响有效TCP连接数量，导致性能出现瓶颈。因此对于高并发服务器，建议调小TIME_WAIT超时时间。毕竟现在网络和路由处理能力大大增强，大部分跨国延时都在1s以内，丢包率极低，基本不会出现这么长时间的超时。

TCP四次挥手中，客户端和服务端各状态：

客户端：ESTABLISHED(连接建立状态)、FIN_WAIT_1（关闭连接请求发送状态）、FIN_WAIT_2（关闭连接请求响应状态，即半关闭状态）、TIME_WAIT（连接关闭前的等待状态）、CLOSED（关闭状态）

服务端：ESTABLISHED(连接建立状态)、CLOSE_WAIT（等待关闭状态，此时进行关闭前的准备工作），LAST_ACK（关闭确认状态，即半关闭状态）、CLOSED（关闭状态）

### 1.6、连接池

​		通过连接来进行系统之间的交互，服务器可以快速创建和断开多个来连接，但对于高并发的后台服务器而言，连接的频繁断开和创建时非常重的负担。因此为了保证连接的使用效率，我们可以通过连接池的方式实现：首先，在客户端和服务端之间事先创建若干连接，放入到连接池中，当需要使用时直接从连接池获取；使用完成后，又放入连接池，从而减少频繁创建连接和释放连接的开销。如RPC服务集群的注册中心和服务器提供方、消费方之间的连接、后台服务器和数据库之间的连接、消息服务集群的缓存服务器和消费者服务器之间的连接

​	以数据库连接池为例，数据库来连接池负责分配、管理和释放连接，通过以内存空间换取时间的策略，来有效提升数据库连接访问的性能。数据库连接池有重要两个参数，数据库初始化最小连接数（MIN）和数据库最大连接数。当MIN过小，就会导致数据库第一时间进行多个数据库访问请求的响应时间增长，影响数据库访问效率；MIN过大，就会导致连接资源浪费；MAX过小，就会导致在高并发下，出现多个请求处于等待状态，不能有效利用数据库最大性能；MAX过大，就会导致在高并发下，数据库连接占满，而自身请求处理能力不足，导致请求超时，影响整个服务器应用。使服务器宕机。

​	在实际应用中，假如数据库配置的MAX为100，一个请求平均处理时间为10ms，则该数据库最大处理=100/10ms =10000QPS（每s查询量，反应数据库处理性能）

​	连接数的增加，只是为了更好的满足高并发场景；但是设置更大的连接数是治标不治本。影响数据库请求响应时间的关键，在于数据库本身的使用优化（数据库MAX一般只设置为30）：

1、建立高效且合适的索引。索引谁都可以建，但想要建好难度极大。因为索引既有数据特征，又有业务特征，数据量的变化会影响索引的选择；业务的不同，索引的优化思路也不一样

2、排查资源为关闭的错误代码。当数据库连接数一直保持很高值时，说明出现了来连接未关闭的情况。这样会大大浪费数据库资源，影响数据库高并发性能，甚至导致数据库崩溃

3、合理拆分多表join的sql，通过应用层面上的逻辑代码，简化高处理量的sql语句

4、使用临时表，有时不断地嵌套查询中，无法有效利用索引提升查询效率，因此可以将中间结果保存到一张临时表中，并对其进行索引创建，之后通过临时表进行后续数据操作

5、改用其他数据库。不同数据库针对的业务场景时不同的，应该合理选择后台数据库

6、应用层优化。对数据结构优化、并发多线程改造等

### 1.7、信息安全

#### 1.7.1黑客与安全

​		黑客（Hacker），黑客地攻击手段十分多样，大体分为非破坏性攻击和破坏性工具。非破坏性攻击时为了扰乱系统的运行，使之暂时失去正常对外提供服务地能力，如DDOS攻击等；破坏性攻击主要是两种后果，系统数据受损或者信息被窃取，如CSRF攻击等。攻击手段有病毒式、洪水式、系统漏洞式等。

​		对于所有互联网企业，都需要建立一套完整的信息安全体现，遵循CIA原则，即保密性（Confidentiality）、完整性（Integrity）、可用性（Availability）

- 保密性，对需要保护的数据（如用户私人信息等）进行保密操作，无论是存储还是传输，都需要保证用户数据及相关资源的安全。如数据传输时使用各种编码加密验证，而黑客不只可以通过网络进行数据窃取，还有可能重企业内部窃取数据，因此对于敏感数据，存储使用密文。

- 完整性。访问的数据需要是完整的，不能被随意篡改或产生缺失。因此在实际开发中，需要对访问到的数据或提交到后台的数据进行签名和校验（如MD5和数字签名等）

- 可用性。服务需要时可用的，保证应用服务不会收到黑客攻击，导致无法提供相应功能。

  web安全问题都是以这三点为基础展开，常见web安全问题有：

#### 1.7.2、SQL注入

​		sql注入式注入式攻击中最常见类型。SQL注入攻击是后台程序员未将代码与数据严格隔离导致的，在读取用户提交的数据时，错误的将数据作为了sql语句的一部分。这样会对数据库数据的安全和业务逻辑操作产生意想不到的影响，如更新/删除数据库中表的该字段所有数据、跳过用户认证等

​		预防方法有：

1、前端过滤用户输入参数中的特殊字符，降低sql注入风险

2、严格使用参数绑定的方式进行sql传参，禁止使用sql拼接

3、合理使用数据库访问框架中的防注入机制，如Mybatis 提供 #{}绑定参数

#### 1.7.3、XSS与CSRF

​		XSS(Cross-Site Scripting)，跨站脚本攻击，为了不和前端开发中的层叠样式表（CSS）名字冲突，简称为XSS。XSS是指黑客通过技术手段，向正常用户请求的HTML页面插入恶意脚本，从而可以执行任意脚本。XSS主要分为反射型XSS、存储型XSS和DOM型XSS。XSS主要用于信息窃取和破坏等目的。

- 反射型XSS，最常见的一种XSS攻击方式，直接通过给别人发送带有恶意脚本的url。当url地址被打开时，恶意脚本代码就会被HTML解析、执行。特点是非持久化，必须欺骗用户自己访问该url才能触发
- 存储型XSS，将恶意脚本存入服务器后台，当目标用户再次访问该页面时，页面就会加重之前后台存储的恶意脚本。特定是持久化，由于需要将脚本存储到服务器中，因此一般出现在网站留言、评论、博客日志中；当用户访问页面，页面请求后台获取你带有恶意脚本的评论后，进行页面加载时，就会触发该脚本
- DOM型XSS，是一种特殊的反射型XSS，同样是使用url进行触发，关键点在于恶意脚本攻击对象为DOM

​		防范XSS，主要是通过对用户输入数据进行过滤或HTML转义实现。有效避免出现脚本输入。

​		CSRF（Cross-Site Request Forgery），跨站请求伪造。在用户不知情的情况下，冒充用户发起请求，在已登陆的Web应用程序中进行恶意操作，如发帖、修改密码、发邮件等

CSRF和XSS的区别：从攻击效果上，两者有重复的地方（获取用户登入信息）；从技术原理上，有本质区别，XSS是正常用户请求的HTML页面中执行了黑客提供的恶意脚本。CSRF是黑客直接盗用用户浏览器中的登录信息，冒充用户执行黑客指定操作;Xss问题出现在用户数据没有过滤、转义；CSRF问题出现在对HTTP接口没有防范不受信任的调用

​		如用户A登录了自己的网银，此时黑客发送给他一个链接，用户点击后，此时就会执行其中的脚本利用当取浏览器保存的网银网站的用户认证，来进行转账操作的HTTP调用；

​		防范CSRF漏洞的主要方式为：

1、进行CSRF Token认证，通过Token来保存认证信息，并绑定到http的header中，导致黑客无法使用cookie中的认证信息来跳过服务端的Token认证

2、人机交互，对于这种需要高安全的操作调用，应该配置短信验证码进行校验

#### 1.7.4、HTTPS

​	在网络通信中，如何保证网络传输数据的加密，是网络安全的重要环境。SSL协议（Secure Socket Layer 安全套接字层），该协议工作在传输层和应用层之间，为应用提供数据的加密传输。而HTTPS即为HTTP over SSL，就是在应用层HTTP传输上增加SSL协议的加密功能。

​	而SSL安全协议建立的基础，就是RSA加密算法。最早的非对称式加密算法，它定义了公开密钥密码体制。即使用不同的加密密钥（公开密钥，公钥）和解幂密钥（私有密钥，私钥），并且加密密钥是通过解密密钥计算出来的，但加密密钥无法反向推导出解密密钥。

​	在RSA算法中，是基于大质数分解的困难性来保证加密的可靠性的。在实际数据安全加密传输中，双方互相知道对方的公钥，然后使用对方的公钥对数据进行加密，传递给对方。到达密文的一方，使用自己保存的私钥进行解码。期间即使双方公钥被获取，也无法对数据进行解密。

​	因此，HTTPS就是通过上面方式来进建立安全的SSL连接的。非对称加密传输过程如下：

1、A告诉B，使用RSA算法进行加密。B收到并同意

2、AB双方分别生成一组RSA密钥，并互相发送公钥

3、A使用收到的B的公钥，对数据加密、发送

4、B收到密文后，使用自己的私钥进行解密。

5、之后B也可以使用同样方式给A发送密文，A用自己私钥解密

非对称加密并非完美，它由一个明显的缺点，就是加密速度慢。只适合少量数据加密处理。因此在通过非对称加密算法建立SSL连接后，会使用对称加密算法（如DES）进行后面数据的加密。而其密钥则在SSL连接建立中，双方确定。

​    在这个过程中，看似无懈可击，但是如果在第(2)步中，A发送自己的密钥给B时，数据包被截获并篡改，使用黑客自己生成的一对RSA密钥中的公钥。B在不知情的情况下，使用该公钥给B发送信息，此时数据被截获时，黑客就能使用自己的私钥进行密文破解，即HTTPS中用于进行对称式加密的密钥被获取，之后所有传输信息都能被破解

​	因此为了解决HTTPS协议使用中的该问题，在基于HTTPS进行连接时，添加一个数字证书，也叫CA（Certificate Authority  认证授权组织）数字证书。用于在搭建SSL连接时，对HTTPS网站服务端请求进行身份认证。此时访问一个HTTPS网站，过程如下：

1、浏览器向服务器发送Client Hello请求，请求中包括浏览器支持的协议（目的是告诉服务器自己支持那些加密协议），并附带一个随机值

2、服务器收到请求后，选择某种非对称加密算法，把该网站的CA数字证书中的签名公钥、身份信息发送给浏览器（目的是告诉浏览器，使用的TLS版本、加密套件，并验证数字证书的真实性），同时也附带一个i而随机值

3、浏览器收到后，验证证书的真实性，发送握手信息（握手信息不会加密）和使用服务器发送的公钥加密的Finish数据（验证加密通道的可行性）给服务器（目的是对服务器发送的证书信息、数据加密方式进行确认）

4、服务器通过之前的随机值，计算出一个对称加密的密钥，并使用SSL连接进行发送（当服务器接收到浏览器的握手信息后，则确定SLL连接建立）。此时服务器和浏览器双方，就都是用该密钥进行数据加密传输

TSL（Transport Layer Security 传输层安全协议）：从大协议栈的角度而言，它和SSL没有太大区别。可以理解位SSL协议3.0版本的升级。

加密套件：确定使用何种 非对称式加密(如RSA)进行何种 对称式加密密钥（如DES）进行加密

### 1.8、编程语言的发展

​		第一代，机器语言时代。机器语言的编程就是单纯的0与1的二进制。直接对机器芯片进行指令操作，因此极大的收到硬件环境的影响。如汇编语言

​		第二代，高级语言时代。各种高级语言百花齐放。无论是面向过程，还是面向对象，都是面向问题编程。

## 2、面向对象

### 2.1、OOP（Object-Oriented Programming）理论

#### 1、面向对象和面向过程的区别：	

- 面向过程：把需求理解成一条条的业务流程，然后将所有流程组合划分成一个个功能模块，对应成相应的代码函数；面向过程关注于业务流程，因此当业务发生改变时，会极大的影响代码的修改，并难以维护；这样大大增加了开发效率，并无法面对实际开发过程中的需求变更

- 面向对象：将需求理解为一个个事物对象，每个对象都定义了自己复杂的事物（我是谁、我从哪里来、我能做什么）；通过对象将容易发生改变的代码封装起来，从而在实现代码复用的同时，极大的降低的代码之间的耦合

- 虽然两者在理论上有本质的区别，但它们同为编程语言，对于程序员只是一个工具；因此即使使用面向过程语言，也可以将程序写的非常内聚、扩展性好。只是说达成该目的会更加麻烦

#### 2、OOP产生的原因：

实现代码的可维护性、可重复性和可扩展性，让模块与模块直接实现高内聚、低耦合。有效降低软件开发开发成本、维护成本和复用成本

#### 3、OOP的三特性：

封装、继承和多态：

- 封装，通过类的权限修饰关键字，来控制类中属性和行为的访问权限，从而实现了代码的高内聚、低耦合，并更加具有维护性；
- 继承，使子类可以继承父类的部分行为和属性，实现代码之间的复用；
- 多态，子类在继承父类代码的同时，可以对行为进行重写；一个类可以有多个子类，因此一个父类类型变量可以指向多种子类类型实例，并实现行为的多态（即在不确定实例类型的情况下，使用父类类型变量接收，让程序拥有多种运行状态）；因此在代码复用的基础上，更加具有扩展性（只需要新增子类，而不需要改变原来代码）
- 抽象，类是由属性和行为组成，属性代表了类的对事物的描述，行为通过操作属性来代表事物的行为；抽象本质上就是将一些事物的共有属性和行为模板（不定义行为的方法体）放在一起作为一个类，再以该类为模板，多样化的创建具体实现，完成从共性到个性、本质到具体的形象化演变

### 2.2、java语言特性

跨平台、分布式、多线程、类库丰富、开发高效、社区健壮；让开发者能使用优雅的思维方式处理复杂问题的编程

### 2.3、类

#### 2.3.1、类的定义

​	1、类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实现；类型分为class、Interface（接口）、enum（枚举）：**注意static只能修饰内部类**

​	2、类由成员和方法组成；先定义成员，后定义方法；对于方法书写顺序：构造方法、公开方法、私有方法、getter/setter

#### 2.3.2、接口与抽象类

​	接口和抽象类是对类的抽象体现，仅定义公共行为和特征，并且不能直接实例化，但两者也有区别：

| 语法                 | 抽象类    | 接口                                   |
| -------------------- | --------- | -------------------------------------- |
| 定义关键字           | abstract  | interface                              |
| 子类继承或实现关键字 | extends   | implements                             |
| 具体方法             | 可以存在  | JAVA8前不能，之后提供default关键字实现 |
| 方法访问权限         | 无限制    | 默认为public abstract                  |
| 属性访问权限         | 无限制    | 默认为public static final              |
| 静态方法/静态代码块  | 可以存在  | JAVA8前不能存在，之后支持静态方法      |
| 同类型扩展           | 单继承    | 多继承                                 |
| 扩展关键字           | extends A | extends A,B                            |

​	一般情况下，优先使用接口，然后在使用抽象类对接口行为进行进一步分层扩展

#### 2.3.3、内部类

1、在一个类的内部定义类，前者叫外部类，后者叫内部类，按照内部类定义位置，可以分为四类：

- 成员内部类：private class AClass：（一般情况下，访问权限使用私有，原因：作为成员变量时，一般只是给自己使用，从而通过内部类实现”多继承“：在内部类使用继承，获取额外的方法处理外部类属性）
- 静态内部类：static class  BClass（一般情况下，访问权限使用包内，原因：使用更小权限时，会导致外部无法通过 "外部类.内部类" 的形式进行直接访问；使用public会使作用域过大）
- 局部（方法）内部类：定义在方法内部：（没有访问权限关键字，因为内部类的作用域只在该方法中，并通过内部类实现“多继承”，通过在方法中创建该对象来使用）
- 匿名内部类：对接口进行实例化，作为对象使用；

```java
	//成员内部类
	private class ClassA{
		//属性和行为
	}
	
	//静态内部类
	static class ClassB{
		//属性和行为
	}

	public void test(){
        //匿名内部类
		Runnable runnable = new Runnable() {
			public void run() {
				//行为代码
			}
		};
        
        //局部内部类
        class ClassC{
            //属性和行为
        }
    }        
```

2、四种内部类对外部类属性和行为的访问：

- 对于成员、匿名、局部内部类，编译器会隐式创建外围类对象的引用，从而在内部类中可以直接使用外部类变量和方法；当出现内部类中的变量名和外部类重名且类型相同时，会默认都使用内部类，可以通过外部类名.this.变量名区分，但是为了方便一般避免重名
- 对于静态内部类，只能直接访问外部类的静态方法和成员，而非静态则需要通过创建外部类对象进行访问

- 由于匿名内部类（也可以存在为外部类的成员变量初始化中）和局部内部类都存在于外部类方法中，因此可能需要对方法作用域中的变量进行操作，此时就需要保证操作的变量被final修饰，原因：

  内部类的生命周期和外部类方法是不一样的，当方法执行完后，内部类并不会销毁；此时该变量就会随着方法被销毁，为了解决这个问题，内部类在获取该变量时，会对该变量引用进行copy（基本类型则创建变量直接指向值的内存空间），此时就需要保证当前引用/内存空间的值不发生改变，才能满足代码逻辑。因此需要使用final对变量进行修饰

3、四种内部类使用场景：

- 成员内部类，保证类的高内聚同时，单纯的实现多继承，实现灵活的代码，并提供给外部类使用
- 局部内部类，在成员内部类的基础上，进一步缩小内部类的作用域，只提供给单个方法使用

- 匿名内部类,创建对接口实现类的同时，直接获取该类的实例对象.从而更加简洁方便的创建接口具体实现类对象,并实现内部类对外部类成员的访问
- 静态内部类，表示了该内部类不依赖于外部类而存在，外界可以直接进行访问；其中可以使用main方法，从而使用静态内部类进行单元测试，再打包时删除静态内部类的class文件，不让生产代码有过多的注解冗余
- 非静态内部类不能创建静态变量和方法；而静态内部类可以创建静态变量和方法；静态内部类，严格意义上就是一个外部类，只是为了满足类的单一职责设计原则，让它隐藏在外部类中，属于它的一部分，只给外部类使用；但是又可以直接单独实例化调用（即披着内部类的外衣，对外声明，但又可以直接调用，只是在类型上，会表明为是某某类的内部类）

4、所有内部类在编译时，都会生成class文件，命令方式如下：

成员内部类和静态成员内部类：  OuterClass$innerClass.class

匿名内部类： OuterClass$1.class 使用数字按顺序代指内部类

局部内部类：OuterClass$1innerClass.class 在内部类类名前面添加数字代指方第几个方法

5、内部类的闭包特性：

- 闭包：通过一个可以调用的对象（内部类），来保存    它被创建时所在的作用域  中的一些信息（如获取外围类成员变量）

- 作用：

1、对于匿名、局部内部类，实现作用域的数据共享，通过将当前数据赋值给一个final变量，从而内部类就能获取到此变量副本，从而使该变量的声明周期延长

2、对于成员内部类，可以延长外部类的生命周期，并更简单的实现java回调

```java
//老板类
public class BossTest {
	// 员工类
	private class EymTest {
		public void work() {
			System.out.println("员工开始工作");
			try {
				Thread.sleep(3000L);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			endWork(); //通过内部类特性，回调外部类方法
		}
	}

	public void sentWork() {
		EymTest eymTest = new EymTest();
		eymTest.work();//调用内部类方法
	}

	public void writeWork() {
		for (int i = 0; i < 10; i++) {
			System.out.println(i + "s");
			try {
				Thread.sleep(500L);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	public void endWork() {
		System.out.println("上个工作结束，进行下一步指示");
	}

	public static void main(String[] args) throws InterruptedException {
		BossTest bossTest = new BossTest();
		Thread thread = new Thread(() -> bossTest.sentWork());
		thread.start();//异步进行内部类的方法调用
		bossTest.writeWork();//主线程执行其他方法
	}
}
```

#### 2.3.4、访问权限

| 访问权限控制符 | 访问权限            |
| -------------- | ------------------- |
| public         | 任何地方            |
| protected      | 同包所有类+包外子类 |
| 无             | 同包所有类          |
| private        | 当前类下            |

访问权限控制符的使用：

**在满足修饰对象（方法、属性、内部类）的使用下，尽量降低修饰对象的访问权限**

#### 2.3.5、this和super关键字

- this：

  1、用于访问当前对象的属性和方法（如 this.name）

  2、用于作为构造方法，在另一个构造方法中实现代码重用（如 this()）

  3、单独使用时，可以代指当前对象（如同步锁使用this）

- super：

  1、用于调用父类的构造方法（使用默认构造器时，会隐式添加super（））

  2、用于访问当前对象父类的属性和方法（如 super.name，属性和方法必须是可继承的）

**this和super关键字，在构造方法中出现时，必须有且只能有一个，并且存在于构造方法的第一行**

#### 2.3.6、类关系

| 类型 | 关键字                             | 关系       | 示例                               |
| ---- | ---------------------------------- | ---------- | ---------------------------------- |
| 继承 | extends                            | is-a       | 小狗类继承动物类                   |
| 实现 | implements                         | can-do     | 小狗类实现狗叫接口                 |
| 组合 | 类的成员变量（生命周期和类一致）   | contains-a | 小狗类包含狗头类这个对象属性       |
| 聚合 | 类的成员变量（生命周期和类不一致） | has-a      | 小狗类有狗绳这个对象属性           |
| 依赖 | import                             | use-a      | 人实现喂养小狗，将小狗作为依赖使用 |

组合比聚合的整体关系更强，它的部分是随着整体一起产生、一起消亡，共同实现一个功能；而聚合只是在整体创建时，将部分放入其中，部分的初始化和消亡与整体无关

#### 2.3.7、类的序列化

内存中，数据对象只能转换为二进制才能进行持久化和网络传输。而将数据对象转换为二进制流的过程就叫做对象的序列化；反之，将二进制流转化为数据对象的过程称之为反序列化。

​	1、序列化优化方向：

序列化需要保留充分的信息来恢复数据对象，但又需要节约存储空间、网络带宽，并满足高频率的转换需求，因此需要有**更好的转换性能和能转换为更小的二进制流**

​	2、java常见序列化方式：

- JAVA原生序列化，通过类实现Serializable接口来实现该类的可序列化。该方式保留了对象类的元数据（类、成员变量、继承类信息等），以及对象数据；兼容性最好，但不支持跨语言，并且性能一般

  同时实现Serializable接口的类需要设置serialVersionUID字段值，定义该类序列化和反序列化时的唯一ID，用于在程序在接收序列化的二进制流时，可以通过serialVersionUID来匹配自己对应的可以序列化类，进行反序列化转换；因此在两个系统通过java原生序列化方式进行对象传递时，需要保证两个系统中，该类的serialVersionUID值保存一致

  当不默认指定serialVersionUID值时，java会自动更加当前类的数据，生成一个；因此当两边系统其中一方添加额外字段后，就会导致两边类的serialVersionUID值不一致，出现序列化失败

  因此一般情况下，不推荐使用java原生序列化

- Hessian序列化，是一种支持动态类型、跨语言、基于对象传输的网络协议，java对象序列化后的二进制流可以被其他面向对象编程特点的语言（c++、Python）反序列化。Hessian协议有如下特性：

  1、自描述序列化类型，用一个字节来表示常用的基础类型，极大地缩短了二进制流

  2、与语言无关，支持脚本语言（JS）

  3、协议简单，比java原生序列化高效

  缺点：Hessian会将复杂对象所有属性存储在一个Map中，进行序列化。对于父类和子类出现同名变量成员时，Hessian序列化会先序列化子类，然后序列化父类，导致子类同名成员变量值被父类覆盖

- JSON序列化，是一种轻量级数据交换格式，JSON序列化就是将数据对象转换为JSON字符串，序列化中抛弃了类型信息，因此在反序列化时，需要手动指定转换的类型。JSON可读性比较好，方便调试

3、序列化攻击：

序列化通常使用在网络传输中，而往往对象数据中会有敏感信息，因此常常被黑客攻击获取利用。因此对于不需要进行传输的对象数据，可以通过transient关键字进行屏蔽

并且黑客会常常利用序列化工具的漏洞，来构造恶意二进制数据，使得程序在反序列化时出现错误，甚至出现OOM，如fastjson、jackson等序列化类库都出现过反序列化漏洞

### 2.4、方法

#### 2.4.1、方法签名

方法签名包括方法名称和参数列表，这是JVM标识方法的唯一索引，不包括返回值、权限访问符等（在使用方法时，使用者**不一定需要方法返回值/或者使用两种方法返回值的共同父类变量接收**，因此使得代码在阅读时，如果返回值也作为方法标识，则就不知道调用的哪个方法），示例：

```
int f(){
    return 1;
}

double f(){
    return 1d;
}

Number a =f();//此时number父类接收，就无法知道调用的是哪个方法，
```

#### 2.4.2、方法参数

​	1、在方法中，参数叫做parameter，在框架注解中，常使用prarm单词作为参数注解，如mybatis预编译时的参数注入；

​	2、方法形参和实参

​	方法参数分为形参和实参；形参为方法定义阶段，实参为方法实际调用时，传递到方法体中的参数；即是将实参值传递给形参，作为方法变量参数方法体的执行；当方法体中出现形参和实参名相同时，更加最近原则，会使用形参进行操作；并且实参传递给形参值的过程，无论是基础数据类型还是引用类型，都是进行值的复制，即实参和形参执行的内存地址不一样，只是值相同。

​	3、可变参数

​	JDK5中引入了可变参数，用于解决反射机制和printf方法问题，使用于不确定参数个数的场景；如printStream类中的printf方法，对多个字符串进行同时打印，定义方式为  参数类型 ...;但由于可变参数过于灵活，极大的影响了代码的可读性和可维护性，因此一般情况下，尽量不要使用，一定要使用则满足

- 只有参数类型相同，且多个参数的业务含义相同的参数，才能作为可变参数

- 方法中只能使用一个可变参数，且放在方法最后

- 不要使用Object类型作为可变参数

  4、参数预处理

  方法定义后，并不能保证调用者传入预期的参数值，为了保证方法的正常运行，需要对参数进行预处理：

- 入参保护：对于一些批量插入的方法，需要对参数量进行上限设置，放在数据处理量过大，影响系统正常使用
- 参数校验：对参数值进行特定的校验，保证参数值符合方法的正常处理条件。使用场景比入参保护要多得多，但是对于频繁调用的代码，会大大降低代码性能

#### 2.4.3、构造方法

构造方法是一个特殊的静态方法，用于对象的实例化。有如下特定：

1、方法名和类名相同、并且没有返回类型（也不能使用void）而是返回当前类的对象；

2、构造方法不会因为public而被子类继承、重写和直接调用，只能通过super、new 关键字、反射进行调用

3、类在创建时，会隐式创建一个无参构造方法；当手动定义有参构造方法，则会被覆盖，只能手动显式定义

4、构造方法可以为private，用于防止类在外部被实例化（如单例）

#### 2.4.4、类中的方法类型

在面向过程的语言中，所有方法都为全局静态方法，在面向对象之后，方法归属于具体的类。类中方法除了构造方法外，还有3类：

1、实例方法：又称为非静态方法，只能通过类的实例进行调用；并且在class文件在加载后，并不会分配方法对于外部调用的入口地址，只有在对象创建后，才会被分配；因此在类实例化前，只能被内部方法调用（即构造方法）

2、静态方法：又称为类方法，类加载后，即分配相应的内存空间，并且静态方法中不能使用实例成员变量和方法；也不能使用super、this关键字

3、静态代码块：同时也存在非静态代码块，但是一般不推荐使用（会在实例化时提前到构造方法中执行，优先于构造方法中的代码，但可以直接使用private的实例方法替代，阅读性更强）；静态代码块会在类加载时，就被调用，并且只会执行一次，一般配合静态变量赋值使用

#### 2.4.5、getter/setter方法

​	getter/setter方法仅提供了对类成员属性的读取和修改，满足面向对象语言封装特性，尽可能的将属性定义为private，使用getter/setter方法进行属性的访问和修改，而不是直接对类属性进行修改，这样也有利于统一控制，对类属性的访问和修改，如在一些使用反射功能的框架中。

​	最典型使用getter/setter方法的类，是POJO（plain ordinary java Object 简单普通的JAVA对象）。只包含getter、setter、toString方法，常见pojo类包括DO(Domain Object)、BO（Business Object）、DTO（Data Transfer Object）、VO（View Object）、AO（Application Object）

#### 2.4.6、重写和重载

重写：子类对父类方法重构，来满足子类的需求

重载：同一方法名，有不同参数列表的方法，本质上是不同方法（因为方法签名不同）

动态绑定：对象实例化时，可以使用父类类型变量进行接收，只有当创建具体实例化对象时，变量才会绑定对应的方法入口地址；JVM使用一个方法表来存储所有可实例化类的方法入口地址，每个类都有自己的对应的方法表数据，当子类继承父类时，则会绑定从父类继承的方法入口地址，对于重写的方法则会保存自身的方法入口地址。

向上转型：当使用父类类型变量接收子类实例化对象时，通过动态绑定，从JVM方法表中获的父类所有方法入口地址，然后查看当前实例化子类是否有重写方法，有则会代替掉父类对应的方法入口地址

### 2.5、泛型

泛型的本质是类型参数化，解决不确定具体对象类型的问题

在java引入泛型之前，使用Object来代表可变类型，然后再通过强转来获的响应对象，这样既大大降低了代码的可读性，又会存在强行转换时的类型转换风险。而泛型就完美解决了这个问题，将类型参数化，从而实现通过不同类型参数，进行不同的处理并返回对应类型的返回值

```java
public <T> T test(T s){
    return s;
}
```

泛型常与集合一起使用，定义集合保存的对象类型，有利于集合使用（在获取集合对象时，可以显式获取当前集合保存的对象类型）

### 2.5、数据类型

#### 2.5.1、基础数据类

java提供八种基础数据类型，指不可再分的原子数据类型，在内存中直接存储此类型的值；包括有：boolean、byte、char、short、int、long、float、double；除了这八种基础数据类型外，java还隐式使用了另一个原子数据类型refvar，它就是面向对象类型的引用变量，也叫引用句柄。该类型代表了引用对象的引用，保存了对象的在堆中的内存地址

| 序号 | 类型名称 | 默认值    | 大小 | 最小值    | 最大值      | 常量池缓存区间 |
| ---- | -------- | --------- | ---- | --------- | ----------- | -------------- |
| 1    | boolean  | false     | 1B   | 1（true） | 0（false）  | true、false    |
| 2    | byte     | （byte）0 | 1B   | -128      | 127         | -128~127       |
| 3    | char     | '\u0000'  | 2B   | ’\u0000‘  | ‘\uFFFF’    | 0~127          |
| 4    | short    | short(0)  | 2B   | -2^15     | 2^15 -32767 | -128~127       |
| 5    | int      | 0         | 4B   | -2^31     | 2^31-1      | -128~127       |
| 6    | long     | 0L        | 8B   | -2^63     | 2^63-1      | -128~127       |
| 7    | float    | 0.0f      | 4B   | 1.4E-45   | 3.4e+38     | 无             |
| 8    | double   | 0.0d      | 8B   | 4.9E-324  | 1.798e+308  | 无             |

对于char的初始值，表示为NUL，即一个空的不可见字符，转换为int就为0；由于0默认为int类型，因此其他类型默认值虽然是0，但需要做强行转换，或特殊表达



​	refvar引用指向对象，简称为refobj。refvar默认值为null，存储refobj的首地址；无论是那种对象的引用，refvar都占用4B空间；而refobj占用12B，用于存储对象基本信息，即对象头，但由于内存分配必须为8B的倍数，因此refobj初始化空间最少为16B；如Integer包装类，refobj对象基础大小为12B，内部成员int占用4B，因此Integer实例化后，占用16B内存空间；同理Double对象占用24B

对象内存存储结构：

1、对象头(Object Header),占用12字节，存储内容包括对象标记和类元信息，其中对象标记存储对象本身运行时的数据，如哈希码、GC标记、锁信息、线程关联信息等，占用8字节；而类元信息存储的是对象的类元数据首地址，和refvar开销一致，占用4个字节

2、实例数据，存储对象实例化的成员变量、和所有可见父类成员变量

3、对象填充，对于前两个占用内存空间总和不会8B倍数时，自动填充使总占用内存为8B的倍数

![](C:\Users\OneMTime\Desktop\Typora图片\对象内存存储结构.jpg)

#### 2.5.2、包装类型

java对八种基本数据类型提供相应的包装类，从而以对象形式进行基础数据的操作，如泛型参数化、序列化、类型转换、数据缓存等。

包装类提供了缓存功能，当对包装类对象直接赋值时，默认调用了valueOf()方法，该方法会先判断缓存区间是否存在该值，没有则通过new来创建该对象（JDK9中，将包装类的new方法标记为过时，推荐使用valueOf（）来合理利用缓存）。但是Float和Double除外，它们没有缓存区间；另外Integer可以通过VM参数，来对缓存区间进行修改，从而提高对Integer类型的缓存能力

**当相同值的基础类型和包装类进行==比较时，不管包装类时new，还是使用常量池，都会自动进行拆箱处理，即使用栈中的值，因此比较会全部相等；而对于相同值的包装类比较，就需要判断两者是使用堆空间还是常量池；因此对于包装类的比较，应该使用equal（)方法**

#### 2.5.3、字符串

String是最常用的数据类型，但它本身还是对象，但JVM对其进行了优化，从而使对String直接赋值时，也可以使用常量池进行缓存，使得直接赋值和new赋值内存空间绝对不可能相同（因此基础类型包装类，缓存池只有-128-127，而String则没有限制）

## 3、代码风格

具体参考阿里巴巴JAVA开发手册（java代码规范）

## 4、走进JVM

​	JVM：java虚拟机，一个虚构出来的计算机（符合计算机架构规范），但可以运行在实际计算机上，提供模拟各种计算机功能；

JVM屏蔽了java代码在具体计算机硬件平台运行的相关细节，而是统一基于JVM进行运行，实现“一次编译，到处运行”，从而实现JAVA跨平台特性

### 4.1、字节码

1、机器码：

​	计算机只能识别0与1的信号，所有计算机底层指令都是通过0和1组合构成的，这些组合的代码也就叫做机器码，它们是离CPU指令集最近的编码，可以直接被CPU解读，但这样也使得机器码与计算机底层硬件系统有很高的耦合

2、字节码：

​	但是用机器码时，一个程序就会因为运行的硬件平台的不同，编写多套代码；因此就需要一个中间码，来阻断程序代码和硬件系统的耦合。JAVA就提供这种中间码，也叫做字节码。

​	Java所有指令有200个左右，一个字节（8位）可以代表256种信号，刚好满足所有指令编码需要，所有java使用一个字节来存储表示所有的指令。也因此被称只为字节码(ByteCode)

3、class文件：

​	java通过编译java文件，获的class文件，即二进制的字节码文件。初始的4个字节非常特殊，为cafe babe 0000 0037， cafe babe 为魔法数，意思为coffee Baby，用于标记该文件为java的class文件，没有则无法被JVM执行；0000 0037 为当前class文件编译使用的JDK版本号

4、字节码所表示的java指令集：

1、加载/存储指令

​	在栈帧（Stack Frame）中，

###栈帧：是实现函数调用的一种数据结构，在栈中保存函数被调用时的 返回地址和参数、临时变量、函数调用的上下文

4.2、类加载过程

4.3、内存布局

4.4、对象实例化

4.5、垃圾回收